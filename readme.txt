readme.txt
battleship.py
By: Brennan Kuo and Ryan Schloessmann
CS 111, 3/16/14

Our version of battleship is a graphics-based game, with all input directed through clicking in the graphics window.  We have two windows, one where the player's ships are placed and that the AI fires at, and one where the AI's ships are placed and that the user fires at.  The information for where ships are located and where the AI and user are fired are stored in lists, similar to ClassyTicTacToe.  Each of the boards (the firing board and the ship board) are located in a different instances of the listed board.  Within our program, we have three different classes: a BattleshipBoard class, a user class, and an AI class.

The BattleshipBoard class is the one that draws the board.  It does this by drawing the grid that the game is played on, drawing and changing square colors when a move is made, checking if the move is legal, check if a ship (either user or AI) has been hit, check if a ship has been sunk, and check if the game is over.  The shipsNotTouching functions is used mainly by the AI for more strategic placement of the AI's ships on the board.  The instructions function prints out to the board the instructions needed at each step along the way.

The AI class is the class that controls for the AI's movements.  The placement function works by randomly choosing two points and then checking to see if these two points fit the criteria(either shipsNotTouching or isLegalPlacement) to be the start and end points of the ship that is currently being placed.  The findLargestShip and the fiveSpacesInRowOrCol are helper functions that contribute to the isOptimalMove function. The fiveSpacesInRowOrCol function checks if there are 5 adjacent unshot squares left anywhere on the user's board and if so isOptimalMove requires that the move made be in a spot where there are at least 2 unshot squares on both sides(either vertically or horizontally) of the possible square to be fired on. If there are not five adjacent unshot squares left on the user's board then isOptimalMove requires only the shot to have 1 unshot square on both sides instead of 2. If The Patrol Boat is the largest ship(findLargestShip) then isOptimalMove only requires that there be 1 unshot adjacent square to the one being fired upon.  The simpleMove function is the function that randomly fires at a spot on the board, provided that it passes through the isOptimalMove and isLegalMove and is found to be both a legal and an optimal move.  When the AI gets a hit, it appends 'H' to the end of a list.  At the beginning of the next firing sequence, the AI checks the last item in the list, and if it is not 'H', it fires randomly as it did before.  If the last item in the list is 'H', simpleMove calls the function smartMove, which focuses on that hit location and continually fires first to the right until it gets a miss, then to the left until it misses, then down, then up in relation to the original hit location.  For each miss, it will append 'HR', 'HL', 'HD', or 'HU'(whichever is the next direction in the sequence) to a new list, depending on which direction it was firing in the first place.  The AI will continue to fire in the direction that the last item in the second list indicates until it misses something.  Then, it will go back to the location indicated in the first list and continue with firing in a square around this location.  Eventually, when the ship has been sunk, 'sunk' will be appended to the first list, causing the ship to then use simpleMove rather than smartMove. An added feature in the smartMove function are targetShips, while trying to sink the ship simpleMove randomly hit, if smartMove hits a different ship it is recorded and smartMove will fire on that ship once it is done sinking the original ship. It can have 5 target ships at one time, in the off chance that the user puts all their ships next to each other. The next time smartMove is called it randomly chooses whether to start firing with 'HR' or 'HD' so the AI doesn't become predictable with its firing sequence(If we always fired horizontally after getting a hit then the user could simply place all ships vertically). Whenever the AI gets a hit, the square will be colored red, and whenever the AI misses, the square will be colored white.

The user class is the class that takes user input through clicking and applies it to the board and list.  The userClick function takes the user's click location and simplifies it to a larger row and column that encompasses many click locations through the use of integer division.  The placement function works in a similar way to the placement function for the AI, but takes the user input rather than random input.  It also draws a square and colors it gray for the placement of the ship.  The move function takes user input and fires at the location specified through the click.  It checks to see if the move is legal and if the move is a hit.  If it is a hit, the square will be colored red.  If it is a miss, it will color the square white.  the endClick function is not connected directly to the user playing the game, but rather takes user input in a third window when asking if the user wants to play again.

The main functions is a large while loop, similar to what was used for ClassyTicTacToe.  After drawing all the graphics to the window, there will be a smaller while loop that alternates between the user and the AI move if the game is not over.  Then, depending on who won the game, the screen prints out a different sentence to the graphics windows saying who won.  Then, a third window pops up asking the user if he or she wants to play again.  This is where the endClick function is used, as it takes the click on the yes or no button and either quits if it is no, or calls the restart_program function.  By calling this function, the program shuts down and is restarted, allowing the game to properly reset without a need to undraw and redraw all of the boxes and lines drawn in the last game.

To run the program, go to the terminal and change directories to the directory that the file is stored in. Make sure graphics.py is also in the directory. Then, run the file how it is usually run.  Python graphics windows should open up, and instructions are given at the bottom of the screen on how to play the game.  Everything is click based, so nothing needs to be typed into the terminal after the program has started.